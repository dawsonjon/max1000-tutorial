module top (
	input CLK12M,
	input USER_BTN,
	output reg [7:0] LED,
	inout [8:1] PIO,
	
	inout [5:0] BDBUS,
	inout [14:0] D
);

wire voted;

assign D[0] = BDBUS[0]; // BDBUS[0] is USB UART TX (FPGA RX)
assign BDBUS[1] = voted; // BDBUS[1] is USB UART RX (FPGA TX)

assign D[1] = voted;

wire nreset;
assign nreset = USER_BTN;

wire clk;
assign clk = CLK12M;

wire [7:0] dout;
wire valid;
wire ready;

assign D[2] = valid;
assign D[3] = ready;

uart_rx U2 (
	.nreset(nreset),
	.clk(CLK12M),
	.rx(BDBUS[0]),
	.voted_o(voted),
	//.cmax_o(LED),
	.data(dout),
	.valid(valid),
	.ready(ready)
);	

uart U1 (
	.nreset(nreset),
	.clk(CLK12M),
	.tx_valid(valid),
	.tx_ready(ready),
	.tx_data(dout),
	.tx(D[4])
);

always @(posedge CLK12M or negedge nreset)
	if (~nreset) begin
		LED <= 8'b0;
	end else begin
		if (valid) begin
			LED <=  dout;
		end
	end

/*
wire [7:0] dataout;
assign LED[3:0] = dataout[3:0];

wire [7:0] i2c_data;
wire [7:0] i2c_addr;

wire i2c_request;
wire i2c_busy;
wire i2c_error;
wire config_ready;

assign LED[5] = config_ready;
assign LED[6] = i2c_error;

sequencer_v2 SEQ1 (
	.nrst(nreset),
	.clk(clk),
	.i2c_req(i2c_request),
	.i2c_busy(i2c_busy),
	.i2c_error(i2c_error),
	.i2c_addr(i2c_addr),
	.i2c_data(i2c_data),
	.ready(config_ready)
);

i2c_master I2C1 (
	.nrst(nreset),
	.clk(clk),
	.request(i2c_request),
	.busy(i2c_busy),
	.error(i2c_error),
	
	.devaddr(7'h1A),
	.rnw(1'b0),
	.regaddr(i2c_addr),
	.datain(i2c_data),
	.dataout(dataout),
	
	.SDA(PIO[5]),
	.SCL(PIO[1])
);


wire AUDIO_CLK; 	// (Green)  MCLK =    12.288MHz from SSM2604
wire BCLK;			// (Yellow) Bit CLK = MCLK/4 = 3.072MHz
wire DACLRC;		// (Blue)   LRCLK   = MCLK/256 = 48KHz
wire DACDAT;      // (Orange)
wire ADCLRC;		// (Purple) LRCLK   = MCLK/256 = 48KHz
wire ADCDAT; 		// (RED)

assign AUDIO_CLK = PIO[6];
assign PIO[2] = BCLK;
assign PIO[7] = DACLRC;
assign PIO[3] = DACDAT;
assign ADCDAT = PIO[4];
assign PIO[8] = ADCLRC;

wire i2s_load;

reg signed [31:0] r_out;
reg signed [31:0] l_out;
wire signed [31:0] cos1;
wire signed [31:0] sin1;
wire signed [31:0] cos2;
wire signed [31:0] sin2;

always @(posedge AUDIO_CLK or negedge cnt_en)
	if (cnt_en == 1'b0) begin
		l_out <= 32'b0;
		r_out <= 32'b0;
	end else begin
		l_out <= (cos1 + (sin2 >>> 1) );
		r_out <= (sin1 + (cos2 >>> 1) );
	end


reg [31:0] ramp_out;
reg signed [31:0] ramp_inc;

reg [31:0] ramp_out1;
reg signed [31:0] ramp_inc1;

wire cnt_en;
assign cnt_en = nreset & config_ready;

always @(posedge AUDIO_CLK or negedge cnt_en)
	if (cnt_en == 1'b0) begin
		ramp_out = 32'b0;
		ramp_inc =  32'd89_478_485;
		ramp_out1 = 32'b0;
		ramp_inc1 = 9 * ramp_inc + 20000;
	end else begin
		if (i2s_load) begin
			ramp_out <= ramp_out + ramp_inc;
			ramp_out1 <= ramp_out1 + ramp_inc1;
		end
	end

// Cordic

cordic COR1 (
	.nreset(nreset),
	.clock(AUDIO_CLK), 
	.ce(i2s_load), 
	.cosine(cos1), 
	.sine(sin1), 
	.x_start(32'h26D91687), // Must be less than 0.607*2^31
	.y_start(32'h00000000), 
	.angle(ramp_out),
	.angleout()
);

cordic COR2 (
	.nreset(nreset),
	.clock(AUDIO_CLK), 
	.ce(i2s_load), 
	.cosine(cos2), 
	.sine(sin2), 
	.x_start(32'h26D91687), // Must be less than 0.607*2^31
	.y_start(32'h00000000), 
	.angle(ramp_out1),
	.angleout()
);

i2s_master_tx I2S1 (
	.nrst(nreset & config_ready),
	.mclk(AUDIO_CLK),
	
	.bclk(BCLK),
	.lrclk(DACLRC),
	.sdout(DACDAT),
	
	// Avalon ST sink
	.ldata(l_out),
	.rdata(r_out),
	.ready(i2s_load),
	.valid(1'b1)
);



reg[7:0] uart_data;
wire tx_ready;

assign D[2] = tx_ready;

always @(posedge CLK12M or negedge nreset)
	if (~nreset) begin
		uart_data <= 8'b0;
	end else begin
		if (tx_ready) begin
			uart_data <= uart_data + 8'b1;
		end
	end
	
*/

endmodule
